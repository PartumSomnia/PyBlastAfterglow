"""
    pass
"""

import numpy as np
from PyBlastAfterglow.uutils import cgs, axes_reshaper
from scipy import interpolate

from .synchrotron import Synchrotron

def SED_SariPiran97(nu, nu_m, nu_c, p, PmaxF, PmaxS):
    """
    Following Sari & Piran 1997
    :param nu:
    :param nu_m:
    :param nu_c:
    :param p:
    :return:
    """

    if hasattr(nu, '__len__'):  # array treatment
        res = np.zeros(len(nu))
        sc = np.array(nu_m <= nu_c, dtype=bool)  # slow cooling
        fc = np.array(nu_m > nu_c, dtype=bool)  # fast cooling
        if len(sc) > 0:  # Slow cooling
            fil1 = sc & (nu < nu_m)
            fil2 = sc & ((nu >= nu_m) & (nu < nu_c))
            fil3 = sc & (nu >= nu_c)
            res[fil1] = (nu[fil1] / nu_m[fil1]) ** (1. / 3.) * PmaxS[fil1]
            res[fil2] = (nu[fil2] / nu_m[fil2]) ** (-1. * (p - 1.) / 2.) * PmaxS[fil2]
            res[fil3] = (nu_c[fil3] / nu_m[fil3]) ** (-1. * (p - 1.) / 2.) * \
                        (nu[fil3] / nu_c[fil3]) ** (-1. * p / 2.) * PmaxS[fil3]
        if len(fc) > 0:  # fast cooling
            fil1 = fc & (nu < nu_c)
            fil2 = fc & ((nu >= nu_c) & (nu < nu_m))
            fil3 = fc & (nu >= nu_m)
            res[fil1] = (nu[fil1] / nu_c[fil1]) ** (1. / 3.) * PmaxF[fil1]
            res[fil2] = (nu[fil2] / nu_c[fil2]) ** (-1. / 2.) * PmaxF[fil2]
            res[fil3] = (nu_m[fil3] / nu_c[fil3]) ** (-1. / 2.) * (nu[fil3] / nu_m[fil3]) ** (-p / 2.) * PmaxF[fil3]
        return res
    else:  # flaot treatment
        if nu_m <= nu_c:  # slow cooling
            res = 0
            if (nu < nu_m): res = (nu / nu_m) ** (1. / 3.)
            if (nu >= nu_m) & (nu < nu_c): res = (nu / nu_m) ** (-1. * (p - 1.) / 2.)
            if (nu >= nu_c): res = (nu_c / nu_m) ** (-1. * (p - 1.) / 2.) * (nu / nu_c) ** (-1. * p / 2.)
            res *= PmaxS
        else:  # fast cooling
            res = 0
            if (nu < nu_c): res = (nu / nu_c) ** (1. / 3.)
            if (nu >= nu_c) & (nu < nu_m): res = (nu / nu_c) ** (-1. / 2.)
            if (nu >= nu_m): res = (nu_m / nu_c) ** (-1. / 2.) * (nu / nu_m) ** (-p / 2.)
            res *= PmaxF
        return res

def Xintp(pp):
    data_xp = [
        1.4444980694980694, 0.9944136261210208,
        1.4820641682054725, 0.9951191166713027,
        1.4820641682054725, 0.9724149343868285,
        1.4927973392647305, 0.9572435579224101,
        1.5035305103239884, 0.9420721814579918,
        1.5196302669128754, 0.9230991471421099,
        1.5410966090313916, 0.9070816520832391,
        1.5536186419338591, 0.8936162230627284,
        1.5840292932684235, 0.8763981013871924,
        1.6194487577639751, 0.8477393594942589,
        1.6001290498573106, 0.863911976295446,
        1.6484283196239717, 0.8286159040949189,
        1.6698946617424877, 0.8123281211517009,
        1.7074607604498908, 0.7972487992565946,
        1.7128273459795198, 0.7808337068026454,
        1.7342936880980357, 0.7650864996281136,
        1.7632732499580324, 0.746467581612873,
        1.7986927144535838, 0.731088984437128,
        1.825525642101729, 0.7161350134448954,
        1.846991984220245, 0.7033609729980923,
        1.889924668457277, 0.688534311516599,
        1.922124181635051, 0.6747339605524508,
        1.954323694812825, 0.6609336095883027,
        1.975790036931341, 0.647438801449929,
        2.0187227211683734, 0.6351348268889329,
        2.0562888198757765, 0.6223979999914229,
        2.0992215041128084, 0.6092831617774097,
        2.1421541883498403, 0.5972494751007525,
        2.1904534581165014, 0.5847657003384353,
        2.2387527278831625, 0.5697232002710423,
        2.2977851687090816, 0.5576005927976534,
        2.360037560852778, 0.5433411441517004,
        2.421216635890549, 0.530382602844718,
        2.4856156622460968, 0.5171972547478341,
        2.550014688601645, 0.5050930581883057,
        2.609047129427564, 0.49560125278914946,
        2.678812741312741, 0.4848488873728878,
        2.7421384505623636, 0.47591959415041374,
        2.8076107940238373, 0.4680283630924301,
        2.8709365032734593, 0.4603604133302047,
        2.9374821638408593, 0.45062769916457235,
        3.004027824408259, 0.4440303244572723,
        3.061986948128252, 0.4389747658554187,
        3.1371191455430583, 0.43224107204123463,
        3.199371537686755, 0.42706329630907136,
        3.2659171982541544, 0.42100649737044926,
        3.3254862976330366, 0.4160537656811161,
        3.3947152509652505, 0.409916076237978,
        3.4542843503441327, 0.4048191910103307,
        3.5278065721000504, 0.39895570666724656,
        3.6018654524089304, 0.39424368788360376,
        3.6662644787644783, 0.3906085117000302,
        3.7306635051200265, 0.3871535274393493,
        3.7896959459459456, 0.3834458827650472,
        3.858388240725197, 0.37884158741356844,
        3.9335204381400026, 0.3742701966740961,
        4.004359367131106, 0.3703075412567437,
        4.068758393486654, 0.36766342064907986,
        4.138524005371831, 0.36473138468635924,
        4.201849714621453, 0.3623610774571778,
        4.272688643612556, 0.3594255160003136,
        4.3370876699681045, 0.35705168327698866,
        4.406853281853282, 0.3549305109672849,
        4.476618893738458, 0.3511876113515472,
        4.541017920094006, 0.3488137786282224,
        4.610783531979184, 0.34588174266550165,
        4.676255875440658, 0.3432881541405619,
        4.744948170219908, 0.3403055860951171,
        4.803980611045828, 0.33821966872684883,
        4.8791128084606346, 0.3361709649078737,
        4.932778663756924, 0.33293142751152094,
        5.0025442756421015, 0.33032373701000706,
        5.093776229645794, 0.3280779972405644,
        5.190374769179117, 0.3257785916158257,
        5.286973308712438, 0.3231188021453014,
        5.3835718482457615, 0.3202788207518845,
        5.480170387779083, 0.31815960705003843,
        5.576768927312406, 0.3156800095024068,
        5.673367466845727, 0.31320041195477544,
        5.7699660063790486, 0.31072081440714383,
        5.866564545912372, 0.30824121685951245,
        5.952429914386435, 0.6841999123278875,
        5.957796499916064, 0.3053467861676563
    ]
    data_xp = np.reshape(np.array(data_xp), (int(len(data_xp) / 2), 2))
    return interpolate.interp1d(data_xp[:, 0], data_xp[:, 1])(pp)

def PhiPint(pp):
    data_phip = [
        1.0062166154656431, 0.4114136714112666,
        1.0451629272536156, 0.41748522011949685,
        1.1309890587863694, 0.4352108868963911,
        1.2168151903191229, 0.4539524485203539,
        1.2572039580992425, 0.46103900983957213,
        1.3531272815770259, 0.48129823808157235,
        1.4641963929723543, 0.5034106767310167,
        1.5860839243087863, 0.5251294910490668,
        1.620702868120317, 0.5319293256420172,
        1.696431807708041, 0.5467827993381156,
        1.8175981110483992, 0.5661800094094774,
        1.8579868788285185, 0.5703882019953342,
        1.958958798278817, 0.5845489733286391,
        2.090222293564205, 0.6011745162193037,
        2.2315829807946232, 0.6141818128900468,
        2.277020344547257, 0.6178789702260863,
        2.3852045439582916, 0.6268107283083477,
        2.42342962775019, 0.6289642665816388,
        2.5344987391455187, 0.6375314406034999,
        2.584984698870668, 0.6420720891524804,
        2.6859566183209664, 0.6459045962072529,
        2.7364425780461157, 0.6483287971581736,
        2.8303464631348936, 0.6522841482352335,
        2.8828518612490486, 0.6548933614442702,
        2.9989695686168916, 0.6609515736837455,
        3.044406932369526, 0.6610930990550443,
        3.1605246397373694, 0.6649163426309681,
        3.205962003490004, 0.6670896576964045,
        3.311982518912817, 0.6690566030386015,
        3.367517074610481, 0.6708004529318601,
        3.473537590033295, 0.6738679510250482,
        3.518974953785929, 0.6750253712434158,
        3.6350926611537724, 0.6769861409330469,
        3.680530024906407, 0.6779742453435698,
        3.7966477322742502, 0.6801043308410457,
        3.842085096026884, 0.6809231194437237,
        3.948105611449698, 0.6828900647859206,
        3.998591571174847, 0.6846370025054622,
        4.109660682570175, 0.6848230440390058,
        4.155098046322809, 0.6858111484495286,
        4.271215753690653, 0.6867560232920911,
        4.316653117443288, 0.6867282328555452,
        4.4226736328661005, 0.6890338098134317,
        4.480227626952771, 0.6906917666722547,
        4.586392387974799, 0.6928037516261392,
        4.639763259684242, 0.6922196231170257,
        4.738715740745535, 0.6935813545077774,
        4.79122113885969, 0.6937524200838491,
        4.892193058309989, 0.6939954320123121,
        4.948737333202156, 0.6940624378426506,
        5.02682228424372, 0.6961141954800841,
        5.089088301238071, 0.6947215858265036,
        5.144622856935735, 0.6963807778158397,
        5.250643372358549, 0.6964852492717439,
        5.285983544166153, 0.6962943186799191,
        5.392004059588967, 0.6963987901358233,
        5.442490019314116, 0.6967065434886839,
        5.51821895890184, 0.6978454367493543,
        5.573753514599504, 0.6973035232367082,
        5.609093686407109, 0.698128487491952,
        5.7151142018299215, 0.6980636431400113,
        5.772668195916593, 0.6982316208898003,
        5.8766692729504, 0.6979648326989591,
        5.937252424620579, 0.6979277787835645
    ]
    data_phip = np.reshape(np.array(data_phip), (int(len(data_phip) / 2), 2))
    return interpolate.interp1d(data_phip[:, 0], data_phip[:, 1])(pp)

def get_nu_m(Xp, gamma_min, B):
    return  3. / (4. * np.pi) * Xp * gamma_min ** 2. * cgs.qe * B / (cgs.me * cgs.c)

def get_nu_c(gamma_c, B):
    return 0.286 * 3. * gamma_c ** 2. * cgs.qe * B / (4. * np.pi * cgs.me * cgs.c)

def get_pmax(PhiP, Ne, B):
    return np.sqrt(3) * Ne * cgs.qe ** 3. * B / (cgs.me * cgs.c ** 2. * 4. * cgs.pi) * PhiP

class Synchrotron_WSPN99(Synchrotron):

    def __init__(
            self,
            p,
            gamma_min,
            gamma_c,
            B,
            Ne,
            delta_shock=0.,
            ssa=False
    ):
        """
        :Ne: is the comoving NUMBER of electrons (not number density)
        """
        # self.gamma_min = gamma_min
        # self.gamma_c = gamma_c
        self.p = p
        # self.B = B
        # self.Ne = Ne
        # self.delta_shock = delta_shock
        # self.ssa = ssa

        Xp = Xintp(p)
        PhiP = PhiPint(p)

        self.nu_m = get_nu_m(Xp, gamma_min, B)#3. / (4. * np.pi) * self.Xp * gamma_min ** 2. * cgs.qe * B / (cgs.me * cgs.c)
        self.nu_c = get_nu_c(gamma_c, B)#0.286 * 3. * gamma_c ** 2. * cgs.qe * B / (4. * np.pi * cgs.me * cgs.c)
        # self.pprimemax =  Ne * cgs.me * cgs.c ** 2 * cgs.sigmaT * B / (3 * cgs.qe)
        self.pprimemax = get_pmax(PhiP, Ne, B)#np.sqrt(3) * Ne* cgs.qe ** 3.* B / (cgs.me * cgs.c ** 2. * 4. * cgs.pi) * self.PhiP

        super(Synchrotron_WSPN99, self).__init__()

    @classmethod
    def from_obj_fs(cls, R, electons, dynamics, ssa=False):
        idx = int(np.where(dynamics.vals["R"] == R)[0][0])
        assert idx > 0
        return cls(
            electons.p1,
            electons.vals["gamma_min"][idx],
            electons.vals["gamma_c"][idx],
            electons.vals["B"][idx],
            dynamics.vals["M2"][idx]/cgs.mppme, #dynamics.get_last("rho2")/cgs.mppme,
            dynamics.vals["thickness"][idx],
            ssa
        )

    @staticmethod
    def evaluate_sed(
            nuprime,
            nu_m,
            nu_c,
            p,
            pmaxprime
    ):

        if hasattr(nuprime, '__len__') and (not hasattr(nu_m, '__len__')):
            nu_m = np.full_like(nuprime, nu_m)
            nu_c = np.full_like(nuprime, nu_c)
            pmaxprime = np.full_like(nuprime, pmaxprime)

        spectrum = SED_SariPiran97(nuprime, nu_m, nu_c, p, pmaxprime, pmaxprime)

        return nuprime * spectrum

    def sed(self, nuprime):
        return self.evaluate_sed(
            nuprime,
            self.nu_m,
            self.nu_c,
            self.p,
            self.pprimemax
        )
    # @staticmethod
    # def evaluate_sed_power(
    #         nuprime,
    #         gamma_min,
    #         gamma_c,
    #         p,
    #         B,
    #         Ne,
    #         delta_shock=0.,
    #         ssa=False
    # ):
    #     Xp = Xintp(p)
    #     PhiP = PhiPint(p)
    #
    #     nu_m = 3. / (4. * np.pi) * Xp * gamma_min ** 2. * cgs.qe * B / (cgs.me * cgs.c)
    #     nu_c = 0.286 * 3. * gamma_c ** 2. * cgs.qe * B / (4. * np.pi * cgs.me * cgs.c)
    #     pmaxprime = Ne * cgs.me * cgs.c ** 2 * cgs.sigmaT * B / (3 * cgs.qe)
    #     # pmaxprime = self.PhiP * (np.sqrt(3)) * num_e * cgs.qe ** 3 * B / (cgs.me * cgs.c ** 2)  # / (4. * cgs.pi)
    #
    #     if hasattr(nuprime, '__len__') and (not hasattr(nu_m, '__len__')):
    #         nu_m = np.full_like(nuprime, nu_m)
    #         nu_c = np.full_like(nuprime, nu_c)
    #         pmaxprime = np.full_like(nuprime, pmaxprime)
    #
    #     spectrum = SED_SariPiran97(nuprime, nu_m, nu_c, p, pmaxprime, pmaxprime)
    #
    #     return nuprime * spectrum
    #
    # def sed_power(self, nuprime):
    #     return self.evaluate_sed_power(
    #         nuprime,
    #         self.gamma_min,
    #         self.gamma_c,
    #         self.p,
    #         self.B,
    #         self.Ne,
    #         self.delta_shock,
    #         self.ssa
    #     )
